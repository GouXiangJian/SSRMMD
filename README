Author
======

Xiang-jian Gou(xjgou@stu.sicau.edu.cn), Hao-ran Shi(542561234@qq.com)

Date
====

2020-02-12

Cite
====

Shang Gao et al. (2019) published an article in the journal Frontiers in Plant Science 
that has cited SSRMMD. The paper name is : A Novel QTL Conferring Fusarium Crown Rot 
Resistance Located on Chromosome Arm 6HL in Barley. The doi is : 10.3389/fpls.2019.01206

Introduction
============

SSRMMD (Simple Sequence Repeat Molecular Marker Developer) is a tool that doesn't rely
on other softwares and modules. It can mine SSR loci and candidate polymorphic SSR 
molecular markers. It is written in PERL5, so you should have PERL5 on your computer. 
You can download PERL5 from https://www.perl.org/

Download
========

You can download SSRMMD from https://github.com/GouXiangJian/SSRMMD

Install
=======

You don't need to do anything extra, use it directly !

Usage
=====

perl SSRMMD.pl option1 <value1> option2 <value2> ... optionN <valueN>

Options
=======

  -f1 | -fasta1 <STR> : a FASTA file for mining SSR loci. (must be provided)

  -f2 | -fasta2 <STR> : another FASTA file when plan to mine polymorphic loci.

  -o  | -outDir <STR> : specify a directory for storing output file, create
                        directory if it doesn't exist. (default: SSRMMDOUT)

  -p  | -poly   <INT> : 0=mine SSR loci, 1=mine polymorphic loci. (default: 0)

  -mo | -motifs <STR> : threshold of motif. (default: 1=10,2=7,3=6,4=5,5=4,6=4)
                        [ left  of equal : length of motif          ]
                        [ right of equal : minimum number of repeat ]

  -l  | -length <INT> : length of SSR flanking sequence. (default: 100)
                        Note: if option '-p' = 1, Flanking sequences will be 
                        used to check for conservativeness and uniqueness.

  -t  | -thread <INT> : the number of threads for running. (default: 1)

  -me | -method <STR> : Algorithm for exactly checking flanking sequences
                        conservativeness. (default: NO)
                            NO : just simple check by HASH
                            LD : global alignment by Levenshtein Distance
                            NW : global alignment by Needleman-Wunsch algorithm
                        Note: LD and NW will increase the computational time,
                        meanwhile, increase the number of conservative SSRs.

  -r  | -reduce   <FLOAT> : conservativeness pre-alignment by using X% flanking
                            sequences near SSR. (default: 0.1 [X% = 10%])

  -d  | -distance <FLOAT> : if option '-me' = LD, set threshold of Levenshtein
                            Distance. (default: 0.05 [5%])
                            Note: the smaller the Levenshtein Distance, the 
                            higher the sequence identity.

  -i  | -identity <FLOAT> : if option '-me' = NW, set threshold of sequence
                            identity calculated by Needleman-Wunsch algori-
                            thm. (default: 0.95 [95%])

  -sc | -score    <STR>   : mapping score of NW algorithm. (default: 1,-1,-2)
                            Note: here, 1 = match, -1 = mismatch, -2 = indel

  -c  | -change   <FLOAT> : change threshold during pre-alignment. (default: 2)
                            Note: for option '-d', 2 imply that increase 2 fold
                            threshold (0.05 change to 0.1); for option '-i', 2
                            imply that reduce 2 fold (0.95 change to 0.9).

  -g1 | -genome1  <STR>   : genome1 file of fasta1 for check flanking sequences
                            uniqueness in genome-scale. (default: fasta1 file)

  -g2 | -genome2  <STR>   : genome2 file of fasta2 for check flanking sequences
                            uniqueness in genome-scale. (default: fasta2 file)

  -st | -stat     <INT>   : 1=output statistical file, 0=not. (default: 0)

  -a  | -all      <INT>   : 1=output all intermediate file, 0=not. (default: 0)

  -w  | -workLog  <STR>   : create a file to record run log. (default: STDOUT)

  -v  | -version          : show the version information.

  -h  | -help             : show the help information.


Example - just mining SSR loci
==============================

Suppose you have a FASTA file named test.fa !

example1 : Run SSRMMD with all default parameters :
    perl SSRMMD.pl -f1 test.fa

example2 : Set the flanking sequence to 200 bp and output SSR statistics :
    perl SSRMMD.pl -f1 test.fa -l 200 -st 1

example3 : Set the minimum number of repeat with motif length of 2,3 and 4 to 8, 7 and 6 respectively :
    perl SSRMMD.pl -f1 test.fa -mo 2=8,3=7,4=6

example4 : Use 8 threads to mine SSR loci :
    perl SSRMMD.pl -f1 test.fa -t 8

Note : We recommend using multi-threading (-t), and setting the number of threads to
       the number of chromosomes in the genome to maximize the computational speed !
       Of course, you can also set it larger, which is useless for mining SSR loci, 
       but is very useful for developing candidate polymorphic SSR (option '-p').

Example - mining candidate polymorphic SSR
==========================================

Suppose you have two FASTA files named test1.fa and test2.fa !

example5 : Use 20 threads to mine candidate polymorphic SSR :
    perl SSRMMD.pl -f1 test1.fa -f2 test2.fa -p 1 -t 20

example6 : checking flanking sequences conservativeness by Levenshtein Distance :
    perl SSRMMD.pl -f1 test1.fa -f2 test2.fa -p 1 -me LD

Note : The flanking sequences of SSR need to be used for conservativeness check between
       '-f1' and '-f2', and uniqueness check ('-f1' is '-g1', '-f2' is '-g2'), so please
       set a reasonable length.

Output
======

Suppose you have two FASTA files named test1.fa and test2.fa !

1. If you just mining SSR loci, you will get a file (test1.fa.SSRs) suffixed
   with 'SSRs', which includes 12 columns :

        1  - SSR number
        2  - sequence name
        3  - SSR motif
        4  - motif length
        5  - the number of motif repeats
        6  - the total size of SSR
        7  - start position
        8  - end position
        9  - left flanking sequence
        10 - the length of left flanking sequence
        11 - right flanking sequence
        12 - the length of right flanking sequence

2. If you mining candidate polymorphic SSR, you will get three files (test1.fa.SSRs, test2.fa.SSRs,
   test1.fa-and-test2.fa.compare). Two files suffixed with 'SSRs' have the same format as above file,
   and 'test1.fa-and-test2.fa.compare' includes 20 columns :

        1  - SSR number
        2  - sequence name of fasta1
        3  - SSR motif of fasta1
        4  - the number of motif repeats of fasta1
        5  - start position of fasta1
        6  - end position of fasta1
        7  - sequence name of fasta2
        8  - SSR motif of fasta2
        9  - the number of motif repeats of fasta2
        10 - start position of fasta2
        11 - end position of fasta2
        12 - left flanking sequence of fasta1
        13 - the length of left flanking sequence of fasta1
        14 - for left flanking sequence, the Levenshtein Distance (LD) between fasta1 and fasta2
        15 - for left flanking sequence, the sequence identity between fasta1 and fasta2 calculated by Needleman-Wunsch(NW) algorithm
        16 - right flanking sequence of fasta1
        17 - the length of right flanking sequence of fasta1
        18 - for right flanking sequence, the Levenshtein Distance (LD) between fasta1 and fasta2
        19 - for right flanking sequence, the sequence identity between fasta1 and fasta2 calculated by Needleman-Wunsch(NW) algorithm
        20 - polymorphism judgment ( yes = polymorphism, no = monomorphism )

3. If you output all detailed intermediate files (option '-a'), you will get some other files,
   which are similar to the above format.

Additional
==========

We have provided an additional tool 'connectorToPrimer3' to connect SSRMMD and Primer3, you can 
use the following command to see detailed usage :

    perl connectorToPrimer3.pl -h
